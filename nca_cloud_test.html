<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>No-Code Architects Toolkit é›²ç«¯æ¸¬è©¦é é¢</title>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px; 
            background: #f5f6fa;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .test-section { 
            background: white;
            padding: 25px; 
            border-radius: 15px; 
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        .test-section:hover {
            transform: translateY(-5px);
        }
        .test-section h3 { 
            color: #2c3e50; 
            margin-top: 0; 
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        .form-group { 
            margin: 15px 0; 
        }
        .form-group label { 
            display: block; 
            margin-bottom: 8px; 
            font-weight: 600;
            color: #34495e;
        }
        .form-group input, .form-group textarea, .form-group select { 
            width: 100%; 
            padding: 12px; 
            border: 2px solid #e1e8ed; 
            border-radius: 8px; 
            font-size: 14px;
            transition: border-color 0.3s ease;
        }
        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
            border-color: #3498db;
            outline: none;
        }
        .btn { 
            padding: 12px 24px; 
            background: linear-gradient(135deg, #3498db, #2980b9); 
            color: white; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            margin: 8px 5px; 
            font-weight: 600;
            transition: all 0.3s ease;
        }
        .btn:hover { 
            background: linear-gradient(135deg, #2980b9, #1abc9c); 
            transform: translateY(-2px);
        }
        .btn:disabled { 
            background: #bdc3c7; 
            cursor: not-allowed; 
            transform: none;
        }
        .btn-success { background: linear-gradient(135deg, #27ae60, #2ecc71); }
        .btn-danger { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        .btn-warning { background: linear-gradient(135deg, #f39c12, #e67e22); }
        
        .result { 
            margin-top: 20px; 
            padding: 15px; 
            border-radius: 8px; 
            white-space: pre-wrap; 
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }
        .success { 
            background: #d5f4e6; 
            border: 2px solid #27ae60; 
            color: #1e8449; 
        }
        .error { 
            background: #fadbd8; 
            border: 2px solid #e74c3c; 
            color: #a93226; 
        }
        .log { 
            background: #f8f9fa; 
            border: 2px solid #dee2e6; 
            color: #495057; 
            max-height: 300px; 
            overflow-y: auto;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-healthy { background: #27ae60; }
        .status-error { background: #e74c3c; }
        .status-testing { background: #f39c12; animation: pulse 2s infinite; }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .stats-panel {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .stat-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #3498db;
        }
        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ› ï¸ No-Code Architects Toolkit é›²ç«¯æ¸¬è©¦ä¸­å¿ƒ</h1>
        <p>ZEABURéƒ¨ç½²ç’°å¢ƒ | å®Œæ•´åŠŸèƒ½æ¸¬è©¦ | MySQLæ•¸æ“šæŒä¹…åŒ–</p>
        <div>
            <span class="status-indicator" id="serverStatus"></span>
            <span id="serverStatusText">æ­£åœ¨æª¢æŸ¥æœå‹™å™¨ç‹€æ…‹...</span>
        </div>
    </div>

    <!-- æ¸¬è©¦çµ±è¨ˆé¢æ¿ -->
    <div class="stats-panel">
        <h3>ğŸ“Š æ¸¬è©¦çµ±è¨ˆ</h3>
        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-number" id="totalTests">0</div>
                <div class="stat-label">ç¸½æ¸¬è©¦æ•¸</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="successTests">0</div>
                <div class="stat-label">æˆåŠŸ</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="failedTests">0</div>
                <div class="stat-label">å¤±æ•—</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="avgTime">0ms</div>
                <div class="stat-label">å¹³å‡éŸ¿æ‡‰æ™‚é–“</div>
            </div>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="successRate" style="width: 0%"></div>
        </div>
        <div style="text-align: center; margin-top: 10px;">
            æˆåŠŸç‡: <span id="successRateText">0%</span>
        </div>
    </div>

    <!-- æ¸¬è©¦åŠŸèƒ½ç¶²æ ¼ -->
    <div class="test-grid">
        <!-- éŸ³é »è™•ç†æ¸¬è©¦ -->
        <div class="test-section">
            <h3>ğŸµ éŸ³é »è™•ç†æ¸¬è©¦</h3>
            
            <div class="form-group">
                <label>é¸æ“‡éŸ³é »æ–‡ä»¶ï¼š</label>
                <input type="file" id="audioFile" accept="audio/*">
            </div>
            
            <div class="form-group">
                <label>è¼¸å‡ºæ ¼å¼ï¼š</label>
                <select id="audioFormat">
                    <option value="mp3">MP3</option>
                    <option value="wav">WAV</option>
                    <option value="aac">AAC</option>
                    <option value="flac">FLAC</option>
                </select>
            </div>
            
            <div class="form-group">
                <label>éŸ³é »è³ªé‡ï¼š</label>
                <select id="audioQuality">
                    <option value="high">é«˜è³ªé‡</option>
                    <option value="medium">ä¸­ç­‰è³ªé‡</option>
                    <option value="low">ä½è³ªé‡</option>
                </select>
            </div>
            
            <button class="btn" onclick="testAudioConvert()">ğŸ”„ æ¸¬è©¦éŸ³é »è½‰æ›</button>
            <button class="btn btn-success" onclick="testAudioTranscribe()">ğŸ“ æ¸¬è©¦éŸ³é »è½‰éŒ„</button>
            
            <div id="audioResult" class="result"></div>
            <div id="audioLog" class="result log"></div>
        </div>

        <!-- è¦–é »è™•ç†æ¸¬è©¦ -->
        <div class="test-section">
            <h3>ğŸ¬ è¦–é »è™•ç†æ¸¬è©¦</h3>
            
            <div class="form-group">
                <label>é¸æ“‡è¦–é »æ–‡ä»¶ï¼š</label>
                <input type="file" id="videoFile" accept="video/*">
            </div>
            
            <div class="form-group">
                <label>æˆ–è€…è¼¸å…¥è¦–é »URLï¼š</label>
                <input type="url" id="videoUrl" placeholder="https://example.com/video.mp4">
            </div>
            
            <div class="form-group">
                <label>è™•ç†é¡å‹ï¼š</label>
                <select id="videoOperation">
                    <option value="convert">æ ¼å¼è½‰æ›</option>
                    <option value="resize">åˆ†è¾¨ç‡èª¿æ•´</option>
                    <option value="trim">è¦–é »å‰ªåˆ‡</option>
                    <option value="extract_audio">æå–éŸ³é »</option>
                    <option value="thumbnail">ç”Ÿæˆç¸®ç•¥åœ–</option>
                    <option value="caption">ç”Ÿæˆå­—å¹•</option>
                </select>
            </div>
            
            <div class="form-group">
                <label>è¼¸å‡ºè¨­ç½®ï¼š</label>
                <input type="text" id="videoSettings" placeholder="å¦‚ï¼š720p, 00:10-00:30ç­‰">
            </div>
            
            <button class="btn" onclick="testVideoProcess()">ğŸ¥ æ¸¬è©¦è¦–é »è™•ç†</button>
            <button class="btn btn-warning" onclick="testVideoCaption()">ğŸ“‹ æ¸¬è©¦å½±ç‰‡å­—å¹•</button>
            
            <div id="videoResult" class="result"></div>
            <div id="videoLog" class="result log"></div>
        </div>

        <!-- åœ–åƒè™•ç†æ¸¬è©¦ -->
        <div class="test-section">
            <h3>ğŸ–¼ï¸ åœ–åƒè™•ç†æ¸¬è©¦</h3>
            
            <div class="form-group">
                <label>é¸æ“‡åœ–ç‰‡æ–‡ä»¶ï¼š</label>
                <input type="file" id="imageFile" accept="image/*">
            </div>
            
            <div class="form-group">
                <label>è™•ç†é¡å‹ï¼š</label>
                <select id="imageOperation">
                    <option value="resize">å°ºå¯¸èª¿æ•´</option>
                    <option value="convert">æ ¼å¼è½‰æ›</option>
                    <option value="compress">å£“ç¸®å„ªåŒ–</option>
                    <option value="watermark">æ·»åŠ æ°´å°</option>
                </select>
            </div>
            
            <div class="form-group">
                <label>è¼¸å‡ºè¨­ç½®ï¼š</label>
                <input type="text" id="imageSettings" placeholder="å¦‚ï¼š800x600, quality=80ç­‰">
            </div>
            
            <button class="btn" onclick="testImageProcess()">ğŸ“¸ æ¸¬è©¦åœ–åƒè™•ç†</button>
            <button class="btn btn-success" onclick="testImageAnalyze()">ğŸ” æ¸¬è©¦åœ–åƒåˆ†æ</button>
            
            <div id="imageResult" class="result"></div>
            <div id="imageLog" class="result log"></div>
        </div>

        <!-- æ–‡ä»¶ç®¡ç†æ¸¬è©¦ -->
        <div class="test-section">
            <h3>ğŸ“ æ–‡ä»¶ç®¡ç†æ¸¬è©¦</h3>
            
            <div class="form-group">
                <label>é¸æ“‡ä»»æ„æ–‡ä»¶ï¼š</label>
                <input type="file" id="anyFile">
            </div>
            
            <div class="form-group">
                <label>ä¸Šå‚³æ–¹å¼ï¼š</label>
                <select id="uploadMethod">
                    <option value="base64">Base64ä¸Šå‚³</option>
                    <option value="form">è¡¨å–®ä¸Šå‚³</option>
                    <option value="chunk">åˆ†ç‰‡ä¸Šå‚³</option>
                </select>
            </div>
            
            <div class="form-group">
                <label>å­˜å„²é¡å‹ï¼š</label>
                <select id="storageType">
                    <option value="temporary">è‡¨æ™‚å­˜å„²</option>
                    <option value="permanent">æ°¸ä¹…å­˜å„²</option>
                    <option value="archive">æ­¸æª”å­˜å„²</option>
                </select>
            </div>
            
            <button class="btn" onclick="testFileUpload()">ğŸ“¤ æ¸¬è©¦æ–‡ä»¶ä¸Šå‚³</button>
            <button class="btn btn-warning" onclick="testFileList()">ğŸ“‹ æ¸¬è©¦æ–‡ä»¶åˆ—è¡¨</button>
            <button class="btn btn-danger" onclick="testFileDelete()">ğŸ—‘ï¸ æ¸¬è©¦æ–‡ä»¶åˆªé™¤</button>
            
            <div id="fileResult" class="result"></div>
            <div id="fileLog" class="result log"></div>
        </div>

        <!-- å·¥å…·åŒ…åŠŸèƒ½æ¸¬è©¦ -->
        <div class="test-section">
            <h3>ğŸ”§ å·¥å…·åŒ…åŠŸèƒ½æ¸¬è©¦</h3>
            
            <div class="form-group">
                <label>æ–‡æœ¬å…§å®¹ï¼š</label>
                <textarea id="textContent" rows="3" placeholder="è¼¸å…¥è¦è™•ç†çš„æ–‡æœ¬å…§å®¹"></textarea>
            </div>
            
            <div class="form-group">
                <label>è™•ç†é¡å‹ï¼š</label>
                <select id="textOperation">
                    <option value="translate">æ–‡æœ¬ç¿»è­¯</option>
                    <option value="summarize">å…§å®¹æ‘˜è¦</option>
                    <option value="sentiment">æƒ…æ„Ÿåˆ†æ</option>
                    <option value="extract">é—œéµè©æå–</option>
                </select>
            </div>
            
            <div class="form-group">
                <label>ç›®æ¨™èªè¨€ï¼š</label>
                <select id="targetLanguage">
                    <option value="en">English</option>
                    <option value="zh">ä¸­æ–‡</option>
                    <option value="ja">æ—¥æœ¬èª</option>
                    <option value="ko">í•œêµ­ì–´</option>
                </select>
            </div>
            
            <button class="btn" onclick="testTextProcess()">ğŸ“ æ¸¬è©¦æ–‡æœ¬è™•ç†</button>
            <button class="btn btn-success" onclick="testAPIHealth()">â¤ï¸ æ¸¬è©¦APIå¥åº·</button>
            
            <div id="toolkitResult" class="result"></div>
            <div id="toolkitLog" class="result log"></div>
        </div>

        <!-- æ‰¹é‡æ¸¬è©¦é¢æ¿ -->
        <div class="test-section">
            <h3>âš¡ æ‰¹é‡æ¸¬è©¦é¢æ¿</h3>
            
            <div class="form-group">
                <label>æ¸¬è©¦å¥—ä»¶ï¼š</label>
                <select id="testSuite">
                    <option value="basic">åŸºç¤åŠŸèƒ½æ¸¬è©¦</option>
                    <option value="performance">æ€§èƒ½å£“åŠ›æ¸¬è©¦</option>
                    <option value="integration">é›†æˆæ¸¬è©¦</option>
                    <option value="all">å…¨é¢æ¸¬è©¦</option>
                </select>
            </div>
            
            <div class="form-group">
                <label>ä¸¦ç™¼æ•¸é‡ï¼š</label>
                <select id="concurrency">
                    <option value="1">å–®ç·šç¨‹</option>
                    <option value="3">3ä¸¦ç™¼</option>
                    <option value="5">5ä¸¦ç™¼</option>
                    <option value="10">10ä¸¦ç™¼</option>
                </select>
            </div>
            
            <button class="btn btn-success" onclick="runBatchTest()">ğŸš€ é‹è¡Œæ‰¹é‡æ¸¬è©¦</button>
            <button class="btn btn-warning" onclick="runStressTest()">âš¡ å£“åŠ›æ¸¬è©¦</button>
            <button class="btn btn-danger" onclick="stopAllTests()">ğŸ›‘ åœæ­¢æ‰€æœ‰æ¸¬è©¦</button>
            <button class="btn" onclick="clearAllLogs()">ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰æ—¥èªŒ</button>
            
            <div id="batchResult" class="result"></div>
            <div id="batchLog" class="result log"></div>
        </div>
    </div>

    <script>
        // å…¨å±€è®Šé‡
        const BASE_URL = 'https://vidsparkback.zeabur.app';
        let testStats = {
            total: 0,
            success: 0,
            failed: 0,
            times: []
        };
        let currentTestSession = null;

        // åˆå§‹åŒ–é é¢
        document.addEventListener('DOMContentLoaded', function() {
            log('ğŸš€ No-Code Architects Toolkit é›²ç«¯æ¸¬è©¦ä¸­å¿ƒå·²åŠ è¼‰');
            log('ğŸŒ æ¸¬è©¦ç’°å¢ƒ: ' + BASE_URL);
            checkServerHealth();
            loadTestHistory();
        });

        // é€šç”¨æ—¥èªŒå‡½æ•¸
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            
            // è¼¸å‡ºåˆ°æ§åˆ¶å°
            console.log(`[NCA Cloud Test] ${message}`);
            
            // è¼¸å‡ºåˆ°å„å€‹æ—¥èªŒå€åŸŸ
            const logElements = ['audioLog', 'videoLog', 'imageLog', 'fileLog', 'toolkitLog', 'batchLog'];
            logElements.forEach(logId => {
                const element = document.getElementById(logId);
                if (element) {
                    element.textContent += logMessage + '\n';
                    element.scrollTop = element.scrollHeight;
                }
            });
        }

        // é¡¯ç¤ºçµæœ
        function showResult(elementId, message, isSuccess = true) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = message;
                element.className = isSuccess ? 'result success' : 'result error';
            }
        }

        // æ›´æ–°æ¸¬è©¦çµ±è¨ˆ
        function updateStats(success, responseTime) {
            testStats.total++;
            if (success) testStats.success++;
            else testStats.failed++;
            testStats.times.push(responseTime);

            // æ›´æ–°é¡¯ç¤º
            document.getElementById('totalTests').textContent = testStats.total;
            document.getElementById('successTests').textContent = testStats.success;
            document.getElementById('failedTests').textContent = testStats.failed;
            
            const avgTime = testStats.times.reduce((a, b) => a + b, 0) / testStats.times.length;
            document.getElementById('avgTime').textContent = Math.round(avgTime) + 'ms';
            
            const successRate = testStats.total > 0 ? (testStats.success / testStats.total * 100) : 0;
            document.getElementById('successRate').style.width = successRate + '%';
            document.getElementById('successRateText').textContent = successRate.toFixed(1) + '%';
        }

        // æª¢æŸ¥æœå‹™å™¨å¥åº·ç‹€æ…‹
        async function checkServerHealth() {
            try {
                const startTime = Date.now();
                const response = await fetch(`${BASE_URL}/health`);
                const responseTime = Date.now() - startTime;
                
                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('serverStatus').className = 'status-indicator status-healthy';
                    document.getElementById('serverStatusText').textContent = `æœå‹™å™¨æ­£å¸¸ (${responseTime}ms)`;
                    log(`âœ… æœå‹™å™¨å¥åº·æª¢æŸ¥é€šé: ${JSON.stringify(data)}`);
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                document.getElementById('serverStatus').className = 'status-indicator status-error';
                document.getElementById('serverStatusText').textContent = 'æœå‹™å™¨ç•°å¸¸';
                log(`âŒ æœå‹™å™¨å¥åº·æª¢æŸ¥å¤±æ•—: ${error.message}`);
            }
        }

        // å‰µå»ºæ¸¬è©¦æœƒè©±
        async function createTestSession(description) {
            try {
                const response = await fetch(`${BASE_URL}/api/test/session/create`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        session_name: `é›²ç«¯æ¸¬è©¦_${new Date().toLocaleString()}`,
                        description: description
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    currentTestSession = result.session_id;
                    log(`ğŸ“‹ æ¸¬è©¦æœƒè©±å‰µå»ºæˆåŠŸ: ${currentTestSession}`);
                }
                return result;
            } catch (error) {
                log(`âŒ æ¸¬è©¦æœƒè©±å‰µå»ºå¤±æ•—: ${error.message}`);
                return { success: false, error: error.message };
            }
        }

        // è¨˜éŒ„æ¸¬è©¦çµæœåˆ°æ•¸æ“šåº«
        async function recordTestResult(testType, testFunction, endpoint, inputData, outputData, status, executionTime, errorMessage = null) {
            try {
                const response = await fetch(`${BASE_URL}/api/test/record`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        test_type: testType,
                        test_function: testFunction,
                        test_endpoint: endpoint,
                        input_data: inputData,
                        output_data: outputData,
                        test_status: status,
                        execution_time_ms: executionTime,
                        error_message: errorMessage,
                        session_id: currentTestSession
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    log(`ğŸ’¾ æ¸¬è©¦çµæœå·²ä¿å­˜åˆ°æ•¸æ“šåº«: è¨˜éŒ„ID ${result.record_id}`);
                }
                return result;
            } catch (error) {
                log(`âŒ æ¸¬è©¦çµæœä¿å­˜å¤±æ•—: ${error.message}`);
                return { success: false, error: error.message };
            }
        }

        // éŸ³é »è½‰æ›æ¸¬è©¦
        async function testAudioConvert() {
            const fileInput = document.getElementById('audioFile');
            const format = document.getElementById('audioFormat').value;
            const quality = document.getElementById('audioQuality').value;
            
            if (!fileInput.files[0]) {
                showResult('audioResult', 'è«‹å…ˆé¸æ“‡éŸ³é »æ–‡ä»¶ï¼', false);
                return;
            }
            
            const file = fileInput.files[0];
            log(`ğŸµ é–‹å§‹éŸ³é »è½‰æ›æ¸¬è©¦: ${file.name} -> ${format}`);
            
            const startTime = Date.now();
            try {
                const formData = new FormData();
                formData.append('audio', file);
                formData.append('format', format);
                formData.append('quality', quality);
                
                const response = await fetch(`${BASE_URL}/v1/audio/convert`, {
                    method: 'POST',
                    body: formData
                });
                
                const responseTime = Date.now() - startTime;
                const result = await response.json();
                
                if (result.success) {
                    log(`âœ… éŸ³é »è½‰æ›æˆåŠŸï¼ç”¨æ™‚: ${responseTime}ms`);
                    log(`ğŸ”— è¼¸å‡ºæ–‡ä»¶: ${result.output_url}`);
                    showResult('audioResult', `è½‰æ›æˆåŠŸï¼\nè¼¸å‡ºæ ¼å¼: ${format}\næ–‡ä»¶URL: ${result.output_url}\nè™•ç†æ™‚é–“: ${responseTime}ms`);
                    
                    await recordTestResult('nca_toolkit', 'audio_convert', '/v1/audio/convert', 
                        {filename: file.name, format, quality}, result, 'success', responseTime);
                    updateStats(true, responseTime);
                } else {
                    throw new Error(result.error || 'è½‰æ›å¤±æ•—');
                }
            } catch (error) {
                const responseTime = Date.now() - startTime;
                log(`âŒ éŸ³é »è½‰æ›å¤±æ•—: ${error.message}`);
                showResult('audioResult', `è½‰æ›å¤±æ•—: ${error.message}`, false);
                
                await recordTestResult('nca_toolkit', 'audio_convert', '/v1/audio/convert', 
                    {filename: file.name, format, quality}, null, 'failed', responseTime, error.message);
                updateStats(false, responseTime);
            }
        }

        // éŸ³é »è½‰éŒ„æ¸¬è©¦ï¼ˆå•é¡ŒäºŒè§£ç­”ï¼‰
        async function testAudioTranscribe() {
            const fileInput = document.getElementById('audioFile');
            
            if (!fileInput.files[0]) {
                showResult('audioResult', 'è«‹å…ˆé¸æ“‡éŸ³é »æ–‡ä»¶ï¼', false);
                return;
            }
            
            const file = fileInput.files[0];
            log(`ğŸ“ é–‹å§‹éŸ³é »è½‰éŒ„æ¸¬è©¦: ${file.name}`);
            log(`ğŸ¯ æ¸¬è©¦ç«¯é»: /v1/media/transcribe`);
            
            try {
                const startTime = Date.now();
                const formData = new FormData();
                formData.append('media', file);
                formData.append('language', 'zh');
                formData.append('model_size', 'tiny');
                
                const response = await fetch(`${BASE_URL}/v1/media/transcribe`, {
                    method: 'POST',
                    body: formData
                });
                
                const responseTime = Date.now() - startTime;
                const result = await response.json();
                
                if (result.success) {
                    log(`âœ… éŸ³é »è½‰éŒ„æˆåŠŸï¼ç”¨æ™‚: ${responseTime}ms`);
                    log(`ğŸ“ è½‰éŒ„æ–‡æœ¬: ${result.text}`);
                    showResult('audioResult', `è½‰éŒ„æˆåŠŸï¼\næ–‡æœ¬å…§å®¹: ${result.text}\nè™•ç†æ™‚é–“: ${responseTime}ms`);
                    
                    // ä¿å­˜Whisperè½‰éŒ„çµæœåˆ°å°ˆç”¨è¡¨
                    await recordWhisperResult('audio', file.name, result.text, responseTime);
                    updateStats(true, responseTime);
                } else {
                    throw new Error(result.error || 'è½‰éŒ„å¤±æ•—');
                }
            } catch (error) {
                const responseTime = Date.now() - startTime;
                log(`âŒ éŸ³é »è½‰éŒ„å¤±æ•—: ${error.message}`);
                showResult('audioResult', `è½‰éŒ„å¤±æ•—: ${error.message}`, false);
                updateStats(false, responseTime);
            }
        }

        // å½±ç‰‡å­—å¹•æ¸¬è©¦ï¼ˆå•é¡ŒäºŒè§£ç­”ï¼‰
        async function testVideoCaption() {
            const videoUrl = document.getElementById('videoUrl').value;
            const fileInput = document.getElementById('videoFile');
            
            let mediaSource = null;
            let mediaName = '';
            
            if (videoUrl) {
                mediaSource = videoUrl;
                mediaName = videoUrl.split('/').pop();
            } else if (fileInput.files[0]) {
                // å…ˆä¸Šå‚³æ–‡ä»¶ç²å–URL
                const file = fileInput.files[0];
                log(`ğŸ“¤ å…ˆä¸Šå‚³è¦–é »æ–‡ä»¶: ${file.name}`);
                
                const uploadResult = await uploadFileToServer(file);
                if (!uploadResult.success) {
                    showResult('videoResult', 'æ–‡ä»¶ä¸Šå‚³å¤±æ•—ï¼', false);
                    return;
                }
                mediaSource = uploadResult.file_url;
                mediaName = file.name;
            } else {
                showResult('videoResult', 'è«‹é¸æ“‡è¦–é »æ–‡ä»¶æˆ–è¼¸å…¥è¦–é »URLï¼', false);
                return;
            }
            
            log(`ğŸ“‹ é–‹å§‹å½±ç‰‡å­—å¹•ç”Ÿæˆæ¸¬è©¦: ${mediaName}`);
            log(`ğŸ¯ æ¸¬è©¦ç«¯é»: /v1/video/caption`);
            log(`ğŸ”— è¦–é »URL: ${mediaSource}`);
            
            try {
                const startTime = Date.now();
                
                const response = await fetch(`${BASE_URL}/v1/video/caption`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        video_url: mediaSource,
                        language: 'zh',
                        model_size: 'tiny',
                        format: 'srt'
                    })
                });
                
                const responseTime = Date.now() - startTime;
                const result = await response.json();
                
                if (result.success) {
                    log(`âœ… å½±ç‰‡å­—å¹•ç”ŸæˆæˆåŠŸï¼ç”¨æ™‚: ${responseTime}ms`);
                    log(`ğŸ“‹ å­—å¹•æ–‡ä»¶: ${result.subtitle_url}`);
                    showResult('videoResult', `å­—å¹•ç”ŸæˆæˆåŠŸï¼\nå­—å¹•æ–‡ä»¶: ${result.subtitle_url}\nè™•ç†æ™‚é–“: ${responseTime}ms`);
                    
                    // ä¿å­˜Whisperå­—å¹•çµæœåˆ°å°ˆç”¨è¡¨
                    await recordWhisperResult('video', mediaSource, result.subtitle_content, responseTime, result.subtitle_url);
                    updateStats(true, responseTime);
                } else {
                    throw new Error(result.error || 'å­—å¹•ç”Ÿæˆå¤±æ•—');
                }
            } catch (error) {
                const responseTime = Date.now() - startTime;
                log(`âŒ å½±ç‰‡å­—å¹•ç”Ÿæˆå¤±æ•—: ${error.message}`);
                showResult('videoResult', `å­—å¹•ç”Ÿæˆå¤±æ•—: ${error.message}`, false);
                updateStats(false, responseTime);
            }
        }

        // ä¿å­˜Whisperçµæœåˆ°å°ˆç”¨è¡¨
        async function recordWhisperResult(mediaType, mediaUrl, transcribedText, processingTime, srtContent = null) {
            try {
                const response = await fetch(`${BASE_URL}/api/test/whisper/record`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        media_type: mediaType,
                        media_url: mediaUrl,
                        transcribed_text: transcribedText,
                        srt_content: srtContent,
                        processing_time_seconds: processingTime / 1000,
                        model_used: 'tiny',
                        session_id: currentTestSession
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    log(`ğŸ’¾ Whisperçµæœå·²ä¿å­˜åˆ°å°ˆç”¨è¡¨: è¨˜éŒ„ID ${result.record_id}`);
                }
            } catch (error) {
                log(`âŒ Whisperçµæœä¿å­˜å¤±æ•—: ${error.message}`);
            }
        }

        // è¦–é »è™•ç†æ¸¬è©¦
        async function testVideoProcess() {
            const fileInput = document.getElementById('videoFile');
            const operation = document.getElementById('videoOperation').value;
            const settings = document.getElementById('videoSettings').value;
            
            if (!fileInput.files[0]) {
                showResult('videoResult', 'è«‹å…ˆé¸æ“‡è¦–é »æ–‡ä»¶ï¼', false);
                return;
            }
            
            const file = fileInput.files[0];
            log(`ğŸ¬ é–‹å§‹è¦–é »è™•ç†æ¸¬è©¦: ${file.name} - ${operation}`);
            
            const startTime = Date.now();
            try {
                const formData = new FormData();
                formData.append('video', file);
                formData.append('operation', operation);
                formData.append('settings', settings);
                
                const response = await fetch(`${BASE_URL}/v1/video/process`, {
                    method: 'POST',
                    body: formData
                });
                
                const responseTime = Date.now() - startTime;
                const result = await response.json();
                
                if (result.success) {
                    log(`âœ… è¦–é »è™•ç†æˆåŠŸï¼ç”¨æ™‚: ${responseTime}ms`);
                    log(`ğŸ”— è¼¸å‡ºæ–‡ä»¶: ${result.output_url}`);
                    showResult('videoResult', `è™•ç†æˆåŠŸï¼\næ“ä½œé¡å‹: ${operation}\nè¼¸å‡ºæ–‡ä»¶: ${result.output_url}\nè™•ç†æ™‚é–“: ${responseTime}ms`);
                    updateStats(true, responseTime);
                } else {
                    throw new Error(result.error || 'è™•ç†å¤±æ•—');
                }
            } catch (error) {
                const responseTime = Date.now() - startTime;
                log(`âŒ è¦–é »è™•ç†å¤±æ•—: ${error.message}`);
                showResult('videoResult', `è™•ç†å¤±æ•—: ${error.message}`, false);
                updateStats(false, responseTime);
            }
        }

        // åœ–åƒè™•ç†æ¸¬è©¦
        async function testImageProcess() {
            const fileInput = document.getElementById('imageFile');
            const operation = document.getElementById('imageOperation').value;
            const settings = document.getElementById('imageSettings').value;
            
            if (!fileInput.files[0]) {
                showResult('imageResult', 'è«‹å…ˆé¸æ“‡åœ–ç‰‡æ–‡ä»¶ï¼', false);
                return;
            }
            
            const file = fileInput.files[0];
            log(`ğŸ–¼ï¸ é–‹å§‹åœ–åƒè™•ç†æ¸¬è©¦: ${file.name} - ${operation}`);
            
            try {
                const startTime = Date.now();
                const formData = new FormData();
                formData.append('image', file);
                formData.append('operation', operation);
                formData.append('settings', settings);
                
                const response = await fetch(`${BASE_URL}/v1/image/process`, {
                    method: 'POST',
                    body: formData
                });
                
                const responseTime = Date.now() - startTime;
                const result = await response.json();
                
                if (result.success) {
                    log(`âœ… åœ–åƒè™•ç†æˆåŠŸï¼ç”¨æ™‚: ${responseTime}ms`);
                    showResult('imageResult', `è™•ç†æˆåŠŸï¼\næ“ä½œ: ${operation}\nè¼¸å‡º: ${result.output_url}\nè™•ç†æ™‚é–“: ${responseTime}ms`);
                    updateStats(true, responseTime);
                } else {
                    throw new Error(result.error || 'è™•ç†å¤±æ•—');
                }
            } catch (error) {
                const responseTime = Date.now() - startTime;
                log(`âŒ åœ–åƒè™•ç†å¤±æ•—: ${error.message}`);
                showResult('imageResult', `è™•ç†å¤±æ•—: ${error.message}`, false);
                updateStats(false, responseTime);
            }
        }

        // æ–‡ä»¶ä¸Šå‚³æ¸¬è©¦
        async function testFileUpload() {
            const fileInput = document.getElementById('anyFile');
            const method = document.getElementById('uploadMethod').value;
            const storageType = document.getElementById('storageType').value;
            
            if (!fileInput.files[0]) {
                showResult('fileResult', 'è«‹å…ˆé¸æ“‡æ–‡ä»¶ï¼', false);
                return;
            }
            
            const file = fileInput.files[0];
            log(`ğŸ“¤ é–‹å§‹æ–‡ä»¶ä¸Šå‚³æ¸¬è©¦: ${file.name} - ${method}`);
            
            try {
                const startTime = Date.now();
                let response;
                
                if (method === 'base64') {
                    const base64Data = await fileToBase64(file);
                    response = await fetch(`${BASE_URL}/api/file/upload-base64`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            filename: file.name,
                            data: base64Data,
                            storage_type: storageType
                        })
                    });
                } else {
                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('storage_type', storageType);
                    
                    response = await fetch(`${BASE_URL}/api/file/upload`, {
                        method: 'POST',
                        body: formData
                    });
                }
                
                const responseTime = Date.now() - startTime;
                const result = await response.json();
                
                if (result.success) {
                    log(`âœ… æ–‡ä»¶ä¸Šå‚³æˆåŠŸï¼ç”¨æ™‚: ${responseTime}ms`);
                    log(`ğŸ”— æ–‡ä»¶URL: ${result.file_url}`);
                    showResult('fileResult', `ä¸Šå‚³æˆåŠŸï¼\næ–¹å¼: ${method}\næ–‡ä»¶URL: ${result.file_url}\nè™•ç†æ™‚é–“: ${responseTime}ms`);
                    updateStats(true, responseTime);
                } else {
                    throw new Error(result.error || 'ä¸Šå‚³å¤±æ•—');
                }
            } catch (error) {
                const responseTime = Date.now() - startTime;
                log(`âŒ æ–‡ä»¶ä¸Šå‚³å¤±æ•—: ${error.message}`);
                showResult('fileResult', `ä¸Šå‚³å¤±æ•—: ${error.message}`, false);
                updateStats(false, responseTime);
            }
        }

        // å·¥å…·å‡½æ•¸ï¼šæ–‡ä»¶è½‰Base64
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        // ä¸Šå‚³æ–‡ä»¶åˆ°æœå‹™å™¨ï¼ˆå…§éƒ¨ä½¿ç”¨ï¼‰
        async function uploadFileToServer(file) {
            try {
                const formData = new FormData();
                formData.append('file', file);
                
                const response = await fetch(`${BASE_URL}/api/file/upload`, {
                    method: 'POST',
                    body: formData
                });
                
                return await response.json();
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // æ–‡æœ¬è™•ç†æ¸¬è©¦
        async function testTextProcess() {
            const text = document.getElementById('textContent').value;
            const operation = document.getElementById('textOperation').value;
            const targetLang = document.getElementById('targetLanguage').value;
            
            if (!text.trim()) {
                showResult('toolkitResult', 'è«‹è¼¸å…¥æ–‡æœ¬å…§å®¹ï¼', false);
                return;
            }
            
            log(`ğŸ“ é–‹å§‹æ–‡æœ¬è™•ç†æ¸¬è©¦: ${operation}`);
            
            const startTime = Date.now();
            try {
                
                const response = await fetch(`${BASE_URL}/v1/text/process`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        text: text,
                        operation: operation,
                        target_language: targetLang
                    })
                });
                
                const responseTime = Date.now() - startTime;
                const result = await response.json();
                
                if (result.success) {
                    log(`âœ… æ–‡æœ¬è™•ç†æˆåŠŸï¼ç”¨æ™‚: ${responseTime}ms`);
                    showResult('toolkitResult', `è™•ç†æˆåŠŸï¼\næ“ä½œ: ${operation}\nçµæœ: ${result.result}\nè™•ç†æ™‚é–“: ${responseTime}ms`);
                    updateStats(true, responseTime);
                } else {
                    throw new Error(result.error || 'è™•ç†å¤±æ•—');
                }
            } catch (error) {
                const responseTime = Date.now() - startTime;
                log(`âŒ æ–‡æœ¬è™•ç†å¤±æ•—: ${error.message}`);
                showResult('toolkitResult', `è™•ç†å¤±æ•—: ${error.message}`, false);
                updateStats(false, responseTime);
            }
        }

        // APIå¥åº·æª¢æŸ¥æ¸¬è©¦
        async function testAPIHealth() {
            log('â¤ï¸ é–‹å§‹APIå¥åº·æª¢æŸ¥æ¸¬è©¦');
            
            try {
                const startTime = Date.now();
                const response = await fetch(`${BASE_URL}/health`);
                const responseTime = Date.now() - startTime;
                const result = await response.json();
                
                if (response.ok) {
                    log(`âœ… APIå¥åº·æª¢æŸ¥é€šéï¼ç”¨æ™‚: ${responseTime}ms`);
                    showResult('toolkitResult', `å¥åº·æª¢æŸ¥é€šéï¼\nç‹€æ…‹: ${result.status}\néŸ¿æ‡‰æ™‚é–“: ${responseTime}ms\næ§‹å»ºç‰ˆæœ¬: ${result.fix}`);
                    updateStats(true, responseTime);
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                const responseTime = Date.now() - startTime;
                log(`âŒ APIå¥åº·æª¢æŸ¥å¤±æ•—: ${error.message}`);
                showResult('toolkitResult', `å¥åº·æª¢æŸ¥å¤±æ•—: ${error.message}`, false);
                updateStats(false, responseTime);
            }
        }

        // æ‰¹é‡æ¸¬è©¦
        async function runBatchTest() {
            const suite = document.getElementById('testSuite').value;
            const concurrency = parseInt(document.getElementById('concurrency').value);
            
            log(`âš¡ é–‹å§‹æ‰¹é‡æ¸¬è©¦: ${suite} (${concurrency}ä¸¦ç™¼)`);
            
            if (!currentTestSession) {
                await createTestSession(`æ‰¹é‡æ¸¬è©¦_${suite}_${concurrency}ä¸¦ç™¼`);
            }
            
            showResult('batchResult', `æ­£åœ¨åŸ·è¡Œ${suite}æ¸¬è©¦å¥—ä»¶...`);
            
            // æ ¹æ“šæ¸¬è©¦å¥—ä»¶åŸ·è¡Œä¸åŒçš„æ¸¬è©¦
            const testFunctions = {
                'basic': [testAPIHealth],
                'performance': [testAPIHealth, testTextProcess],
                'integration': [testAPIHealth, testTextProcess, testFileUpload],
                'all': [testAPIHealth, testTextProcess, testFileUpload, testImageProcess]
            };
            
            const tests = testFunctions[suite] || testFunctions['basic'];
            
            try {
                for (let i = 0; i < concurrency; i++) {
                    log(`ğŸš€ å•Ÿå‹•æ¸¬è©¦ç·šç¨‹ ${i + 1}`);
                    for (const testFunc of tests) {
                        await testFunc();
                        await new Promise(resolve => setTimeout(resolve, 1000)); // é–“éš”1ç§’
                    }
                }
                
                showResult('batchResult', `æ‰¹é‡æ¸¬è©¦å®Œæˆï¼\nå¥—ä»¶: ${suite}\nä¸¦ç™¼: ${concurrency}\nç¸½è¨ˆ: ${testStats.total} å€‹æ¸¬è©¦`);
                log(`âœ… æ‰¹é‡æ¸¬è©¦å®Œæˆï¼åŸ·è¡Œäº† ${testStats.total} å€‹æ¸¬è©¦`);
            } catch (error) {
                log(`âŒ æ‰¹é‡æ¸¬è©¦å¤±æ•—: ${error.message}`);
                showResult('batchResult', `æ‰¹é‡æ¸¬è©¦å¤±æ•—: ${error.message}`, false);
            }
        }

        // æ¸…ç©ºæ‰€æœ‰æ—¥èªŒ
        function clearAllLogs() {
            const logElements = ['audioLog', 'videoLog', 'imageLog', 'fileLog', 'toolkitLog', 'batchLog'];
            const resultElements = ['audioResult', 'videoResult', 'imageResult', 'fileResult', 'toolkitResult', 'batchResult'];
            
            [...logElements, ...resultElements].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = '';
                    element.className = element.id.includes('Log') ? 'result log' : 'result';
                }
            });
            
            log('ğŸ—‘ï¸ æ‰€æœ‰æ—¥èªŒå·²æ¸…ç©º');
        }

        // åŠ è¼‰æ¸¬è©¦æ­·å²
        async function loadTestHistory() {
            try {
                const response = await fetch(`${BASE_URL}/api/test/history`);
                const result = await response.json();
                
                if (result.success) {
                    log(`ğŸ“Š è¼‰å…¥æ¸¬è©¦æ­·å²: ${result.total_tests} å€‹æ­·å²æ¸¬è©¦è¨˜éŒ„`);
                    // å¯ä»¥åœ¨æ­¤è™•é¡¯ç¤ºæ­·å²çµ±è¨ˆ
                }
            } catch (error) {
                log(`âš ï¸ ç„¡æ³•è¼‰å…¥æ¸¬è©¦æ­·å²: ${error.message}`);
            }
        }

        // å£“åŠ›æ¸¬è©¦
        async function runStressTest() {
            log('âš¡ é–‹å§‹å£“åŠ›æ¸¬è©¦...');
            showResult('batchResult', 'æ­£åœ¨åŸ·è¡Œå£“åŠ›æ¸¬è©¦ï¼Œè«‹ç¨å€™...');
            
            const testCount = 20;
            const promises = [];
            
            for (let i = 0; i < testCount; i++) {
                promises.push(testAPIHealth());
                if (i % 5 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            try {
                await Promise.all(promises);
                showResult('batchResult', `å£“åŠ›æ¸¬è©¦å®Œæˆï¼\nä½µç™¼åŸ·è¡Œ: ${testCount} å€‹è«‹æ±‚\næˆåŠŸç‡: ${(testStats.success / testStats.total * 100).toFixed(1)}%`);
            } catch (error) {
                showResult('batchResult', `å£“åŠ›æ¸¬è©¦å¤±æ•—: ${error.message}`, false);
            }
        }

        // åœæ­¢æ‰€æœ‰æ¸¬è©¦
        function stopAllTests() {
            log('ğŸ›‘ åœæ­¢æ‰€æœ‰æ¸¬è©¦');
            showResult('batchResult', 'æ‰€æœ‰æ¸¬è©¦å·²åœæ­¢');
            // é€™è£¡å¯ä»¥æ·»åŠ åœæ­¢é‚è¼¯
        }
    </script>
</body>
</html>

